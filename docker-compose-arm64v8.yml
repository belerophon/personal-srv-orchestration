version: '3'

services:

  # a DB server; the underlying DB for NextCloud
  postgres:
    image: arm64v8/postgres:12.5-alpine
    container_name: postgres
    restart: unless-stopped
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/postgres:/var/lib/postgresql/data
    env_file:
      - postgres.env
    logging:
      driver: "none"

  # a key value store; acts as cache for NextCloud
  redis:
    image: arm64v8/redis:6.0.9-alpine3.12
    container_name: redis
    command: redis-server --requirepass somedummypass # this is not exposed and used only in this internal network. It is required because of nextcloud
    restart: unless-stopped

  # maintenance processes that must be run regularly in order for Nextcloud to run properly
  # same image used for the actual nextcloud service below
  nextcloud-cron:
    image: nextcloud:20.0.2-fpm-alpine
    restart: unless-stopped
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/nextcloud:/var/www/html
      - /etc/localtime:/etc/localtime:ro
    entrypoint: /cron.sh
    environment:
      - POSTGRES_HOST=postgres
      - POSTGRES_DB=nextcloud
      - REDIS_HOST=redis
      - REDIS_HOST_PASSWORD=somedummypass
    env_file:
      - postgres.env
    depends_on:
      - postgres
      - redis
    logging:
      driver: "none"

  # a Dropbox alternative, self-hosted
  nextcloud:
    image: nextcloud:20.0.2-fpm-alpine
    container_name: nextcloud
    restart: unless-stopped
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/nextcloud:/var/www/html
      - /etc/localtime:/etc/localtime:ro
    environment:
      - POSTGRES_HOST=postgres
      - POSTGRES_DB=nextcloud
      - REDIS_HOST=redis
      - REDIS_HOST_PASSWORD=somedummypass
    env_file:
      - postgres.env
    depends_on:
      - postgres
      - redis
    logging:
      driver: "none"

  # the actual php server for NextCloud
  nginx-nextcloud-fpm-front:
    build: ./nginx-nextcloud-fpm-front
    container_name: nginx-nextcloud-fpm-front
    restart: unless-stopped
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/nextcloud:/var/www/html:ro
    env_file:
      - nginx-nextcloud-fpm-front.env
    depends_on:
      - nextcloud
    networks:
      - proxy-tier
      - default
    logging:
      driver: "none"

  # torrent client
  transmission:
    image: linuxserver/transmission:arm64v8-latest
    container_name: transmission
    restart: unless-stopped
    environment:
      - TZ=Europe/London
      - PUID=0
      - PGID=0
    env_file:
      - transmission.env
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/media_services/MEDIA:/MEDIA
      - ${DATA_VOLUME_BASE_PATH}/media_services/transmission/config:/config
    ports:
      - 9091:9091
      - 51413:51413
      - 51413:51413/udp
    networks:
      - proxy-tier
      - default
    logging:
      driver: "none"

  # tracker sites proxy for the other two below
  jackett:
    image: linuxserver/jackett:arm64v8-latest
    container_name: jackett
    restart: unless-stopped
    env_file:
      - jackett.env
    ports:
      - 9117:9117
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/media_services/jackett/config:/config
    networks:
      - proxy-tier
      - default
    logging:
      driver: "none"

  # to look for TV series
  sonarr:
    image: linuxserver/sonarr:arm64v8-latest
    container_name: sonarr
    restart: unless-stopped
    environment:
      - TZ=Europe/London
      - PUID=0
      - PGID=0
    env_file:
      - sonarr.env
    depends_on:
      - jackett
      - transmission
    ports:
      - 8989:8989
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/media_services/sonarr/config:/config
      - ${DATA_VOLUME_BASE_PATH}/media_services/MEDIA:/MEDIA
    networks:
      - proxy-tier
      - default
    logging:
      driver: "none"

  # to look for movies
  radarr:
    image: linuxserver/radarr:arm64v8-latest
    container_name: radarr
    restart: unless-stopped
    environment:
      - TZ=Europe/London
      - PUID=0
      - PGID=0
    env_file:
      - radarr.env
    depends_on:
      - jackett
      - transmission
    ports:
      - 7878:7878
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/media_services/radarr/config:/config
      - ${DATA_VOLUME_BASE_PATH}/media_services/MEDIA:/MEDIA
    networks:
      - proxy-tier
      - default
    logging:
      driver: "none"

  # subtitle download with integration with radarr and sonarr
  bazarr:
    image: linuxserver/bazarr:arm64v8-latest
    container_name: bazarr
    restart: unless-stopped
    environment:
      - TZ=Europe/London
      - PUID=0
      - PGID=0
    env_file:
      - bazarr.env
    depends_on:
      - radarr
      - sonarr
    ports:
      - 6767:6767
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/media_services/bazarr/config:/config
      - ${DATA_VOLUME_BASE_PATH}/media_services/MEDIA:/MEDIA
    networks:
      - proxy-tier
      - default
    logging:
      driver: "none"

  # NFS v4 server
  nfs:
    image: itsthenetwork/nfs-server-alpine:latest-arm
    container_name: nfs
    restart: unless-stopped
    environment:
      - TZ=Europe/London
      - READ_ONLY=true
      - SHARED_DIRECTORY=/media
      - PERMITTED="192.168.0.*"
    ports:
      - 2049:2049
    privileged: true
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/media_services/MEDIA:/media:ro
    networks:
      - default

  # a build dependency for the actual nginx-proxy running bellow. This only triggers the image build...
  nginx-proxy-arm:
    image: nginx-proxy-arm # setting this along with "build", makes the build process to tag the image with this name
    build:
      context: ./nginx-proxy
      dockerfile: Dockerfile.arm
    restart: "no"
    container_name: nginx-proxy-arm
    command: "sh -c exit" # ... just exit the running container. We're using this only to trigger an image build...

  # listens to changes on the docker server... if a new running container appears, with certain env vars set, it tries to generate a nginx proxy configuration so as to proxy a virtual host to the running container
  custom-nginx-proxy:
    build: ./custom-nginx-proxy
    container_name: custom-nginx-proxy
    restart: unless-stopped
    ports:
      - 80:80
      - 443:443
    labels:
      com.github.jrcs.letsencrypt_nginx_proxy_companion.nginx_proxy: "true"
    volumes:
      - certs:/etc/nginx/certs:ro
      - vhost.d:/etc/nginx/vhost.d
      - html:/usr/share/nginx/html
      - /var/run/docker.sock:/tmp/docker.sock:ro
    networks:
      - proxy-tier
    depends_on:
      - nginx-proxy-arm

  # listens to changes on the docker server... if a new running container appears, with certain env vars set, it tries to generate an SSL certificate for it.
  docker-letsencrypt-nginx-proxy-companion:
    build: docker-letsencrypt-nginx-proxy-companion
    container_name: docker-letsencrypt-nginx-proxy-companion
    restart: unless-stopped
    volumes:
      - certs:/etc/nginx/certs
      - vhost.d:/etc/nginx/vhost.d
      - html:/usr/share/nginx/html
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - proxy-tier
    depends_on:
      - custom-nginx-proxy
    logging:
      driver: "none"

  # updates your no ip DNS. Useful when you want to use a CNAME for your actual DNS server records... E.g. sub.domain.com -> CNAME -> my.dynamic.noip.com
  rpi-noip:
    image: hypriot/rpi-noip
    container_name: rpi-noip
    restart: unless-stopped
    volumes:
      - ${DATA_VOLUME_BASE_PATH}/noip/config:/usr/local/etc # must supply a valid configuration file inside this folder, otherwise refer to the image on how to build one first.
    networks:
      - default
    logging:
      driver: "none"

volumes:
  certs:
  vhost.d:
  html:

networks:
  proxy-tier:
